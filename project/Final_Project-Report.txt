Final Project Report:
--------------------
This assignment has taken about 10 hours so far.

Project Description:
-------------------
Starting from "My Project Initial Notes.docx"...

Implement some semi-autonomous behavior in my m3pi Robot,
where "semi-autonomous" means:
	independent exploratory behavior, 
		with real-time ongoing reporting of location estimates and room dimensions
	responding to queries
	executing commands
	
Sensors to use:
--------------
I have several types of Sonar and IR Transceiver Sensors to draw from, as well as a 
3-Axis Magnetometer, for which I have code that implements a Tilt-Compensated Compass
on it.

I propose having Sonar facing forward, and IR Transceivers pointing in the other three 
directions, to detect/prevent tangential and backing-up collisions, and ensure parallel
following of walls, with no veering towards or away from them.

Potential Goals/Sub-Tasks/Behaviors/Negative Sensor Feedback Loops:
------------------------------------------------------------------
1. My first Sensor<->Robot Feedback Loop to implement is Robot Rotation tied to the 
   Compass.  This will require using the existing m3pi Library to drive the wheels, 
   line-follower Sensors, PZ Speaker, etc., and implementing I2C communication with 
   my existing 3-Axis Magnetometer and its Tilt-Compensated Compass code.
   
1a. Calibration for Tire Scrub losses, etc., will be attempted by using the Sonar 
    with some sort of Training Jig, i.e., one or two rings of Construction Paper with 
	10-degree wide slots cut in them, where I rotate one ring, to progressively narrow 
	the slots, and/or perhaps use the built-in Line-Following Sensors for rotational 
	calibration on top of a 36-arm Starfish-like Jig of thin Tape.  Both of these Jigs
	I could draw in some graphics program, and just print them.
	
1b. To debug and calibrate the 3-axis Magnetometer (= Tilt-Compensated Compass) and 
	wall-Following, I’ll implement an analog 2-Axis Joystick.
	Pushing the Joystick around in a circle at full-scale deflection will command the 
	Robot to Rotate either clockwise or counter-clockwise, and a smaller deflection 
	(with no circular motion) will command the Robot to rotate to that heading, and 
	start rolling at a speed proportional to the deflection.
	Various tutorials for Joystick programming here:
	    http://learn.parallax.com/KickStart/27800
		https://www.sparkfun.com/tutorials/272
		http://www.arduino.cc/en/Tutorial/JoystickMouseControl

2. Once Rotation is as calibrated as it can be, I want to implement wall-following, 
   where the side-looking Sensors prevent gradually veering, either into, or away from,
   the wall that the Robot is following.
   
3. Once wall-following is working as best it can, I'll try to implement wall distance 
   measurement, to begin the task of creating an X-Y Coordinate System, in which to map 
   the room.
   The distance measurement will be based on combining counting wheel rotations, with 
   Sonar measurements along a wall, to as great a distance as the Sonar can measure 
   accurately.
   
4. Once some basic mapping data collection is working, I want to implement display of 
   the data on a web page pushed out by the robot via a WiFly on it.  I'll try to
   implement both Ad-Hoc and DHCP IP Addressing, in case UCSC Extension's Wi-Fi doesn't
   allow a Server to be added to it.
   
5. Once I have implemented a basic Query & Response web page interface, I want to add 
   either of a HTML5 canvas or svg tag, and in it both display the Robot's path and 
   wall findings, as well as allow directional guidance to be input.
   
6. My ultimate GUI goal is to support multi-touch gestures in the map, i.e., Pinch for 
   Zoom, and 2-finger Twist for rotating the Map.  Theoretically my Laptop's Touch 
   Screen driver can deliver such events to applications, so it's a question if either 
   Java Apps or some combination of Javascript+HTML5+whichever Browser can receive them.

Issues to resolve along the way:
-------------------------------


Findings along the way:
----------------------
Joystick:
  I wanted to check for "unreachable coordinates" with my Joystick, as jerks in its 
  output data may lead to my Robot crashing into the wall, zooming out of control, etc.
  
  The 1st graph in "x_and_y1_and_y2-scan-data.xlsx" shows when I dragged the Joystick 
  from left to right, moved down a tiny bit, then did it again.  This shows pretty uniform 
  coverage, except for Quadrant IV.
  
  For the 2nd graph in the .xlsx file, I dragged the Joystick top to bottom, moved right 
  a tiny bit, then did it again. My first guess is that this shows the Y’s Pot. is very 
  dirty, and has many dead spots.

  I haven't used this Joystick before, so perhaps as I begin to use it more, it will 
  become better behaved over time.  Hope so.
  
  I need to convey my Joystick output to my mbed input (via my XBee Dongle).  I was 
  thinking about writing a little perl script that just reads from COM21 (= my Arduino
  Nano) and writes what it read from there to COM27 (= my mbed).  Luckily, I found here:
  
      http://perlguru.com/gforum.cgi?post=43583;guest=
	  
  where it says that I need to open COM ports > COM9 with this syntax:
	  
	  open( PORT, "\\\\.\\COM21") || die( "open failed.\n");
	  
  So now in the Perl debugger, I can see my Joystick's output data as follows:
  
    DB<7> open( PORT, "\\\\.\\COM21") || die( "open failed.\n");

	DB<9> p <PORT>
		xVal: -2 :yVal: 1
		xVal: 3 :yVal: 1
		xVal: 15 :yVal: 3
		xVal: 5 :yVal: 1
		xVal: -4 :yVal: 1
		[...]
		
In setting up to use the mbed RPC Library that I described here:

    https://groups.google.com/forum/#!topic/spring2015_e4357/Uxt0BtRg5BQ
	
I found that the mbed Cookbook entry that I referred to is now out-of-date, 
so I found another RPC example that does work in developer.mbed.org/compiler 
here:

    https://developer.mbed.org/users/ban4jp/code/SerialRPC_rtos_example/docs/tip/

I.e., in my main.cpp I have:

    #include "mbed.h"
    #include "rtos.h"
    #include "SerialRPCInterface.h"
    #include "RPCVariable.h"

    float f = 42;
    int   i = 43;
    char  c = 'b';
    RPCVariable<float> rpc_f(&f, "f");
    RPCVariable<int> rpc_i( &i, "i");
    RPCVariable<char> rpc_c(& c, "c");
	
	int main()
	{
		SerialRPCInterface rpc( USBTX, USBRX);
	}
	
In my developer.mbed.org/compile program, I've imported these libraries:

	mbed-rpc
	mbed-rtos			// Not sure if this one is needed for our purposes.
	RPCInterface-rtos	// I only use this because the other similar libraries don't compile.
	
In my Serial Terminal program (connected to my mbed), when I just hit the Enter key, 
my mbed sends back this Help message:

    c i f SPI Serial Timer PwmOut DigitalInOut DigitalOut DigitalIn RPC

meaning that "c", "i", and "f" are my variables that I can query and set, 
as well as typing /RPC/something, DigitalIn/something, etc., as shown here:

/c/read		prints:
b
/f/read		prints:
42
/i/read		prints:
43

The caveat so far is that only the first of the above works, then it just prints out the 
Help message in response to further commands.

I'll google more to learn how to clean out the queue, so further commands can work.

And it's bigger than the demo-Keil will allow, so once I get my near-term functionality 
implemented (= the Robot is moving following my Joystick motions), I'll google a bit more 
to find a non-RTOS version of this, that will fit into the demo-Keil.

Update:
I finally realized (after much google'ing), that the newest version of the SerialRPCInterface
code:

	Description: https://developer.mbed.org/cookbook/RPC-Interface-Library
	Code:        https://developer.mbed.org/users/MichaelW/code/RPCInterface/
	
is Version #8 (28 Jan 2012), as shown in developer.mbed.org/compiler, by right-clicking on
this Library in Program Workspace under your program, choosing "Revisions...".

That means that in order to get the SerialRPCInterface Library to compile, I need to 
right-click on the mbed Library for my program, click on "Revisions...", and click on the 
newest version prior to that date, and click on "Switch", which is Version #36 (26 Jan 2012).

Once I switched to this ancient version of the mbed Library, the RPCInterface 
(aka SerialRPCInterface) Library compiles just fine, though it still only works
the first time I send it a query.  

The good news is that now I can compile and debug into it in Keil.  If you have the 
32kByte-limited version of Keil, rather than the 30-day-limited version, to get past
the 302kByte-limit, I propose to comment out some of these lines:

    SerialRPCInterface.cpp:40:
	void SerialRPCInterface::_RegClasses(void){
    //Register classes with base 
>>> // Base::add_rpc_class<AnalogIn>();   <<<<<<<<<
	// ... 
	
Comment out whichever of these add_rpc_class() calls for mbed capabilities that you won't 
be using.  

I.e., I commented them all out except for <AnalogOut>, and my Keil code size became 
28080 bytes during linking, and 30680 bytes loaded into the mbed.

Uncommenting out one add_rpc_class() call added 192 bytes during linking, and 228 bytes 
loaded into the mbed, so you can calculate how many more add_rpc_class()'s you can 
uncomment out, and still fit into the crippled Keil.

Next I'll debug into it and try to see why it only replies to the first command.

In Keil, I unchecked:

  Options for Target->Debug->CMSIS-DAP Debugger->Settings->
    Debug->Stop after Bootloader
	
Doing so causes this error:

    Address execution break already exists, 
	redefine existing breakpoint?
	
Clicking on either of No or Yes causes this error:

    Cannot access target.
	Shutting down debug session.
	
So I left that checked, and tried unchecking this instead:

  Options for Target->Debug->Run to main()
  
This causes the same first error as above, but if you click "No",
it lets the program run to hit your first breakpoint, rather than 
stopping at the start just prior to entering main().

Update:
I should mention that the SerialRPCInterface Library receives RPC calls 
via interrupts, which (I believe) is superior to the polling approach 
in a while (1) loop that you can see here:

    https://developer.mbed.org/questions/3897/AnalogIn-not-working-in-rpc/
	
Update:
Alas, my changes to RPCFunction.cpp were unsuccessful, so I'm setting that 
aside for now in favor of implementing my next functional block, which is 
the data path between my JoyStick+Arduino, to the m3pi left()/right() and 
motor_left()/motor_right() RPC functions, which do work.

To do this, I'll write a very small Perl "bridge" script, which will read
the JoyStick's R+Theta values from COM23, and write the corresponding 
m3pi-RPC commands to the mbed, first via USB on COM28, then later via XBee
on COM20.  When I make that change, the corresponding mbed code change will
be from:

   SerialRPCInterface rpcInterface( USBTX, USBRX);
to:
   SerialRPCInterface rpcInterface( p28, p27);
   
as that's where the m3pi's Radio Socket's TXD and RXD connect to the mbed.

I also have to further increase the noise rejection of the JoyStick program.
I'm thinking of cutting its Theta output into 8 octants.  For the R value, 
I'll first try cutting it down to be one of 5 values: 

	< 75  = noise, i.e., ignore
	next 1/3rd = 1/3rd of full-speed in the specified direction, after rotation
				 with reference to the Tilt-Compensated Compass (= 3-axis Magnetometer)
	next 1/3rd = 2/3ds of full speed, ditto.
	last 1/3rd = full speed, ditto.	
	> 900 = full-scale deflection, = Rotation mode, rather than Bearing mode.

I'll parameterize the lower-noise and full-scale deflection thresholds and the 
number of steps between zero-speed and full-speed, to simplify adjusting them
in response to however noisy the JoyStick turns out to be in actual use.

I found that these noise-filtering settings worked well for this particular JoyStick:

	const int numThetaSectors = 8;
	const int noiseCeiling    = 120;
	const int fullScaleFloor  = 900;
	const int numRadiusRanges = 8;
	
I also added a check to prevent unwanted points when the JoyStick is snapping back to center.

Update:
------
I'm attempting to abandon the Perl JoyStick->mbed Bridge script in favor of
hosting the JoyStick on an Arduino Fio, which will communicate with the mbed
via XBee.

Initially, I'm programming the Fio using this:

   http://moderndevice.com/product/usb-bub-i/
   
which I've jumper'ed to output 3 Volts to the Fio (both Data lines and Vcc), 
as it's a 3V part.

The photo "Arduino-Fio Joystick vs. Arduino-Nano Joystick.jpg" shows the 
new Fio JoyStick hosting arrangement in the foreground (the small red board 
is the FTDI programmer), and the old Nano host (plus XBee carrier, which is
built into the back of the Fio).

I only wish I had soldered these stackable headers:

    http://shop.evilmadscientist.com/partsmenu/251
	
onto the Fio instead of the usual ones, as then it would be much easier to 
wire up the Fio.

Update:
------
Programming the Fio with the USB Bub above works fine, and I can 
communicate with the Fio's running program via XBee as well, but
I can't yet program it via XBee.

To get the Wireless Programming of the Fio working, I'm following the 
steps in the web pages below, which I'll summarize here:

Referring to these photos...

    Fio Wireless Programming Soldering Steps-p1.jpg
    Fio Wireless Programming Soldering Steps-p2.jpg

On the Fio (mine's board is black), there is a very tiny solder jumper point, 
that needs to be closed to support Wireless Programming.

It may or may not already be soldered in when you buy your Fio.  It doesn't
need a wire to close the gap, only a very tiny solder blob.

Your XBee carrier board needs to have a very short wire jumper soldered between
the RTS pad and the Data IO Pin 3 pad.

Solder the wire on the opposite side of the XBee carrier board from where the 
XBee socket is, so you can easily see that the jumper is in place, without 
having to remove the XBee to check.

If you're using Windows, do this step, which I'm quoting from here:

    http://www.jeffhoefs.com/2013/06/wireless-firmata-using-xbees/
	
    In the Device Manager, select the USB COM port. 
	Then right click and select Properties. Click on the Port Settings tab, 
	and click on Advanced..., then make sure "Set RTS On Close" is selected 
	and click OK to apply settings. 
	(these instructions copied from http://arduino.cc/en/Main/ArduinoBoardFioProgramming)
	
I also got some valuable info from here:

	https://www.sparkfun.com/tutorials/122

Referring to those directions above, I updated my XBee's firmware by doing the
following:

	Run X-CTU from digi.com, and inside it, ...
	Click on Modem Configuration->Modem Parameter and Firmware->Read, 
	to determine current firmware version and settings
	Click on on Modem Configuration->Versions->Download new versions.  
	It took quite a while to do that, seemingly downloading every firmware 
	version for every Digi product in the known universe.
	Click on the Version pull-down menu, and choose the newest version.
	Check the "Modem Parameter and Firmware"->"Always Update Firmware" checkbox.
	Click on "Modem Parameter and Firmware"->Write.
	
Once I'd upgraded my firmware, I next used X-CTU to change the following for my 
Remote unit:

	Networking & Security->PAN ID->(my id#, anything in the range: 0-0xffff)
    RF Interfacing->Power Level->(0) Lowest
	Serial Interfacing->Interface Data Rate->(6) 57600 baud
	(57600 is the baud rate used by the Fio's Bootloader, 
	 which is why this speed is used)
	 
	I/O Settings->D3->(5) DO HIGH		# Digital Output, active-high.
	I/O Settings->IU->(0) DISABLED
	I/O Settings->I/O Line Passing->(FFFF)->Set->OK
	
	Networking & Security->MY 16-bit Source Address->(1) This is unit #1.
	
then clicked on "Modem Parameter and Firmware"->Write.

For my Base unit, I did the same, except for:

	I/O Settings->D3->(5) DI	# = Digital Input.
	I/O Settings->DIO Change Detect->(8) # = 0b1000, which is Pin 3
	(no I/O Line Passing change for the Base unit)
	(no Power Level change for the Base unit)
	(no Source Address change for the Base unit)

	Networking & Security->Destination Address High & Low = ffff
	
From here:

	http://www.arduino.cc/en/Main/ArduinoBoardFioProgramming
	
I added in the Base settings:

	Networking & Security->XBee Retries->(3)
	Serial Interfacing->Packetization Timeout->(10)
	
For safe-keeping, I clicked on Modem Configuration->Profile->Save, and saved
a .pro file for both my Base and Remote XBees' configuration.

If you change the Baud Rate, after you write the new settings to your XBee, 
in X-CTU, go back to PC Settings->Com Port Setup->Baud, change it to your 
new speed, and click on Test/Query.

If all went well, it will say, "Success".  If not, try changing the Baud
pull-down menu back to the original speed (usually 9600), and click on 
Test/Query again.

Back in:

    https://www.sparkfun.com/tutorials/122#Step4
	
makes a start at explaining how all this DIO3-fiddling in X-CTU works, to 
facilitate Wireless Programming.

It's explained a bit more thoroughly here:

    http://www.arduino.cc/en/Main/ArduinoBoardFioTips

Here:

	http://forum.arduino.cc/index.php?topic=123835.0
	
it also suggests doing this to both units in X-CTU:

	I/O Settings->DIO7->(0) Disable CTS Flow Control
	
I'm going to try first without this though.

Some more of the above info is spelled out here:

	http://www.semifluid.com/2012/09/07/arduino-fio-low-power-setup/
	
Update:
------

I was reading here on XBees:

	https://www.parallax.com/sites/default/files/downloads/32400-XBee-USB-Adapter-Documentation-v1.0.pdf
    https://davidbeath.com/posts/reading-xbee-rssi-with-arduino.html
	
and thought it might be good to perform this procedure:

	Test Communications Link and Establish a Network: Perform a Range Test

as described here:
	
	http://ftp1.digi.com/support/documentation/90002160_A.pdf
	
I made a few screenshots here:

	"XBee-USB Cable-Trim off corner to fit XBee Carrier-p1.png"
	"XBee-USB Cable-Trim off corner to fit XBee Carrier-p2.png"

showing how I had to trim off the corner of the USB cable's plug, to allow
it to fit when plugging it into the small XBee carrier board.

To perform the test on pg. 12, I added a jumper between DIN and DOUT on the 
XBee carrier board.

In "XBee-Loopback Testing-p1.png", you can see the jumper I added above on 
the "Remote" XBee.

To maximize my Robot's Battery Life, I set the Remote XBee's "RF Interfacing->
Power Level" to (0)-LOWEST.

With this setting, I found that dropped very few packets with the Remote XBee
as far away as in the next room, and was able to keep at least intermittent 
communication up (= the RSSI light stayed on) until I finally entered the room 
at the opposite end of my home.

In the future, I'll want to configure API mode as described in the .pdf file 
above, and as described here:

	http://knowledge.digi.com/articles/Knowledge_Base_Article/Digi-API-Frame-Maker
	
but that can wait for now.

Lastly, the XBee's ignal Strength (via the PWM signal on its RSSI pin) can be 
monitored as described here:

	http://letsmakerobots.com/node/37243
	http://log.liminastudio.com/itp/physical-computing/measuring-xbee-signal-strength-from-the-rssi-pin
	https://davidbeath.com/posts/reading-xbee-rssi-with-arduino.html
	
Update:
------	
	
After doing the above, in my Serial Terminal program I clicked on-and-off the RTS 
signal, which is what the Arduino IDE does to signal the Arduino's Bootloader that 
it's time to receive a new program.

I used an LED+Resistor to confirm on my XBee USB dongle that its RTS pin (now 
jumper'ed to XBee pin DIO3) is toggling when I click on my Serial Terminal's RTS 
button.  

I followed that by using the LED to confirm that on the "Remote" XBee its DIO3 is 
also toggling when I click the Serial Terminal's RTS button.

Lastly, I installed the XBee on the Arduino FIO, and confirmed that the DIO3 pin
is still toggling in sync with the clicking the Serial Terminal's RTS button.

After all this, I tried Wireless Programming the Fio again, and now it works :=).



Results/Solutions:
-----------------
