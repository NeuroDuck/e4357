Final Project Report:
--------------------
This assignment has taken about 10 hours so far.

Project Description:
-------------------
Starting from "My Project Initial Notes.docx"...

Implement some semi-autonomous behavior in my m3pi Robot,
where "semi-autonomous" means:
	independent exploratory behavior, 
		with real-time ongoing reporting of location estimates and room dimensions
	responding to queries
	executing commands
	
Sensors to use:
--------------
I have several types of Sonar and IR Transceiver Sensors to draw from, as well as a 
3-Axis Magnetometer, for which I have code that implements a Tilt-Compensated Compass
on it.

I propose having Sonar facing forward, and IR Transceivers pointing in the other three 
directions, to detect/prevent tangential and backing-up collisions, and ensure parallel
following of walls, with no veering towards or away from them.

Potential Goals/Sub-Tasks/Behaviors/Negative Sensor Feedback Loops:
------------------------------------------------------------------
1. My first Sensor<->Robot Feedback Loop to implement is Robot Rotation tied to the 
   Compass.  This will require using the existing m3pi Library to drive the wheels, 
   line-follower Sensors, PZ Speaker, etc., and implementing I2C communication with 
   my existing 3-Axis Magnetometer and its Tilt-Compensated Compass code.
   
1a. Calibration for Tire Scrub losses, etc., will be attempted by using the Sonar 
    with some sort of Training Jig, i.e., one or two rings of Construction Paper with 
	10-degree wide slots cut in them, where I rotate one ring, to progressively narrow 
	the slots, and/or perhaps use the built-in Line-Following Sensors for rotational 
	calibration on top of a 36-arm Starfish-like Jig of thin Tape.  Both of these Jigs
	I could draw in some graphics program, and just print them.
	
1b. To debug and calibrate the 3-axis Magnetometer (= Tilt-Compensated Compass) and 
	wall-Following, I’ll implement an analog 2-Axis Joystick.
	Pushing the Joystick around in a circle at full-scale deflection will command the 
	Robot to Rotate either clockwise or counter-clockwise, and a smaller deflection 
	(with no circular motion) will command the Robot to rotate to that heading, and 
	start rolling at a speed proportional to the deflection.
	Various tutorials for Joystick programming here:
	    http://learn.parallax.com/KickStart/27800
		https://www.sparkfun.com/tutorials/272
		http://www.arduino.cc/en/Tutorial/JoystickMouseControl

2. Once Rotation is as calibrated as it can be, I want to implement wall-following, 
   where the side-looking Sensors prevent gradually veering, either into, or away from,
   the wall that the Robot is following.
   
3. Once wall-following is working as best it can, I'll try to implement wall distance 
   measurement, to begin the task of creating an X-Y Coordinate System, in which to map 
   the room.
   The distance measurement will be based on combining counting wheel rotations, with 
   Sonar measurements along a wall, to as great a distance as the Sonar can measure 
   accurately.
   
4. Once some basic mapping data collection is working, I want to implement display of 
   the data on a web page pushed out by the robot via a WiFly on it.  I'll try to
   implement both Ad-Hoc and DHCP IP Addressing, in case UCSC Extension's Wi-Fi doesn't
   allow a Server to be added to it.
   
5. Once I have implemented a basic Query & Response web page interface, I want to add 
   either of a HTML5 canvas or svg tag, and in it both display the Robot's path and 
   wall findings, as well as allow directional guidance to be input.
   
6. My ultimate GUI goal is to support multi-touch gestures in the map, i.e., Pinch for 
   Zoom, and 2-finger Twist for rotating the Map.  Theoretically my Laptop's Touch 
   Screen driver can deliver such events to applications, so it's a question if either 
   Java Apps or some combination of Javascript+HTML5+whichever Browser can receive them.

Issues to resolve along the way:
-------------------------------


Findings along the way:
----------------------
Joystick:
  I wanted to check for "unreachable coordinates" with my Joystick, as jerks in its 
  output data may lead to my Robot crashing into the wall, zooming out of control, etc.
  
  The 1st graph in "x_and_y1_and_y2-scan-data.xlsx" shows when I dragged the Joystick 
  from left to right, moved down a tiny bit, then did it again.  This shows pretty uniform 
  coverage, except for Quadrant IV.
  
  For the 2nd graph in the .xlsx file, I dragged the Joystick top to bottom, moved right 
  a tiny bit, then did it again. My first guess is that this shows the Y’s Pot. is very 
  dirty, and has many dead spots.

  I haven't used this Joystick before, so perhaps as I begin to use it more, it will 
  become better behaved over time.  Hope so.
  
  I need to convey my Joystick output to my mbed input (via my XBee Dongle).  I was 
  thinking about writing a little perl script that just reads from COM21 (= my Arduino
  Nano) and writes what it read from there to COM27 (= my mbed).  Luckily, I found here:
  
      http://perlguru.com/gforum.cgi?post=43583;guest=
	  
  where it says that I need to open COM ports > COM9 with this syntax:
	  
	  open( PORT, "\\\\.\\COM21") || die( "open failed.\n");
	  
  So now in the Perl debugger, I can see my Joystick's output data as follows:
  
    DB<7> open( PORT, "\\\\.\\COM21") || die( "open failed.\n");

	DB<9> p <PORT>
		xVal: -2 :yVal: 1
		xVal: 3 :yVal: 1
		xVal: 15 :yVal: 3
		xVal: 5 :yVal: 1
		xVal: -4 :yVal: 1
		[...]
		
In setting up to use the mbed RPC Library that I described here:

    https://groups.google.com/forum/#!topic/spring2015_e4357/Uxt0BtRg5BQ
	
I found that the mbed Cookbook entry that I referred to is now out-of-date, 
so I found another RPC example that does work in developer.mbed.org/compiler 
here:

    https://developer.mbed.org/users/ban4jp/code/SerialRPC_rtos_example/docs/tip/

I.e., in my main.cpp I have:

    #include "mbed.h"
    #include "rtos.h"
    #include "SerialRPCInterface.h"
    #include "RPCVariable.h"

    float f = 42;
    int   i = 43;
    char  c = 'b';
    RPCVariable<float> rpc_f(&f, "f");
    RPCVariable<int> rpc_i( &i, "i");
    RPCVariable<char> rpc_c(& c, "c");
	
	int main()
	{
		SerialRPCInterface rpc( USBTX, USBRX);
	}
	
In my developer.mbed.org/compile program, I've imported these libraries:

	mbed-rpc
	mbed-rtos			// Not sure if this one is needed for our purposes.
	RPCInterface-rtos	// I only use this because the other similar libraries don't compile.
	
In my Serial Terminal program (connected to my mbed), when I just hit the Enter key, 
my mbed sends back this Help message:

    c i f SPI Serial Timer PwmOut DigitalInOut DigitalOut DigitalIn RPC

meaning that "c", "i", and "f" are my variables that I can query and set, 
as well as typing /RPC/something, DigitalIn/something, etc., as shown here:

/c/read		prints:
b
/f/read		prints:
42
/i/read		prints:
43

The caveat so far is that only the first of the above works, then it just prints out the 
Help message in response to further commands.

I'll google more to learn how to clean out the queue, so further commands can work.

And it's bigger than the demo-Keil will allow, so once I get my near-term functionality 
implemented (= the Robot is moving following my Joystick motions), I'll google a bit more 
to find a non-RTOS version of this, that will fit into the demo-Keil.

Update:
I finally realized (after much google'ing), that the newest version of the SerialRPCInterface
code:

	Description: https://developer.mbed.org/cookbook/RPC-Interface-Library
	Code:        https://developer.mbed.org/users/MichaelW/code/RPCInterface/
	
is Version #8 (28 Jan 2012), as shown in developer.mbed.org/compiler, by right-clicking on
this Library in Program Workspace under your program, choosing "Revisions...".

That means that in order to get the SerialRPCInterface Library to compile, I need to 
right-click on the mbed Library for my program, click on "Revisions...", and click on the 
newest version prior to that date, and click on "Switch", which is Version #36 (26 Jan 2012).

Once I switched to this ancient version of the mbed Library, the RPCInterface 
(aka SerialRPCInterface) Library compiles just fine, though it still only works
the first time I send it a query.  

The good news is that now I can compile and debug into it in Keil.  If you have the 
32kByte-limited version of Keil, rather than the 30-day-limited version, to get past
the 302kByte-limit, I propose to comment out some of these lines:

    SerialRPCInterface.cpp:40:
	void SerialRPCInterface::_RegClasses(void){
    //Register classes with base 
>>> // Base::add_rpc_class<AnalogIn>();   <<<<<<<<<
	// ... 
	
Comment out whichever of these add_rpc_class() calls for mbed capabilities that you won't 
be using.  

I.e., I commented them all out except for <AnalogOut>, and my Keil code size became 
28080 bytes during linking, and 30680 bytes loaded into the mbed.

Uncommenting out one add_rpc_class() call added 192 bytes during linking, and 228 bytes 
loaded into the mbed, so you can calculate how many more add_rpc_class()'s you can 
uncomment out, and still fit into the crippled Keil.

Next I'll debug into it and try to see why it only replies to the first command.

In Keil, I unchecked:

  Options for Target->Debug->CMSIS-DAP Debugger->Settings->
    Debug->Stop after Bootloader
	
Doing so causes this error:

    Address execution break already exists, 
	redefine existing breakpoint?
	
Clicking on either of No or Yes causes this error:

    Cannot access target.
	Shutting down debug session.
	
So I left that checked, and tried unchecking this instead:

  Options for Target->Debug->Run to main()
  
This causes the same first error as above, but if you click "No",
it lets the program run to hit your first breakpoint, rather than 
stopping at the start just prior to entering main().

Update:
I should mention that the SerialRPCInterface Library receives RPC calls 
via interrupts, which (I believe) is superior to the polling approach 
in a while (1) loop that you can see here:

    https://developer.mbed.org/questions/3897/AnalogIn-not-working-in-rpc/
	
Update:
Alas, my changes to RPCFunction.cpp were unsuccessful, so I'm setting that 
aside for now in favor of implementing my next functional block, which is 
the data path between my JoyStick+Arduino, to the m3pi left()/right() and 
motor_left()/motor_right() RPC functions, which do work.

To do this, I'll write a very small Perl "bridge" script, which will read
the JoyStick's R+Theta values from COM23, and write the corresponding 
m3pi-RPC commands to the mbed, first via USB on COM28, then later via XBee
on COM20.  When I make that change, the corresponding mbed code change will
be from:

   SerialRPCInterface rpcInterface( USBTX, USBRX);
to:
   SerialRPCInterface rpcInterface( p28, p27);
   
as that's where the m3pi's Radio Socket's TXD and RXD connect to the mbed.

I also have to further increase the noise rejection of the JoyStick program.
I'm thinking of cutting its Theta output into 8 octants.  For the R value, 
I'll first try cutting it down to be one of 5 values: 

	< 75  = noise, i.e., ignore
	next 1/3rd = 1/3rd of full-speed in the specified direction, after rotation
				 with reference to the Tilt-Compensated Compass (= 3-axis Magnetometer)
	next 1/3rd = 2/3ds of full speed, ditto.
	last 1/3rd = full speed, ditto.	
	> 900 = full-scale deflection, = Rotation mode, rather than Bearing mode.

I'll parameterize the lower-noise and full-scale deflection thresholds and the 
number of steps between zero-speed and full-speed, to simplify adjusting them
in response to however noisy the JoyStick turns out to be in actual use.

I found that these noise-filtering settings worked well for this particular JoyStick:

	const int numThetaSectors = 8;
	const int noiseCeiling    = 120;
	const int fullScaleFloor  = 900;
	const int numRadiusRanges = 8;
	
I also added a check to prevent unwanted points when the JoyStick is snapping back to center.

Update:
------
I'm attempting to abandon the Perl JoyStick->mbed Bridge script in favor of
hosting the JoyStick on an Arduino Fio, which will communicate with the mbed
via XBee.

Initially, I'm programming the Fio using this:

   http://moderndevice.com/product/usb-bub-i/
   
which I've jumper'ed to output 3 Volts to the Fio (both Data lines and Vcc), 
as it's a 3V part.

The photo "Arduino-Fio Joystick vs. Arduino-Nano Joystick.jpg" shows the 
new Fio JoyStick hosting arrangement in the foreground (the small red board 
is the FTDI programmer), and the old Nano host (plus XBee carrier, which is
built into the back of the Fio).

I only wish I had soldered these stackable headers:

    http://shop.evilmadscientist.com/partsmenu/251
	
onto the Fio instead of the usual ones, as then it would be much easier to 
wire up the Fio.








Results/Solutions:
-----------------
