Final Project Report:
--------------------
This assignment has taken about 10 hours so far.

Project Description:
-------------------
Starting from "My Project Initial Notes.docx"...

Implement some semi-autonomous behavior in my m3pi Robot,
where "semi-autonomous" means:
	independent exploratory behavior, 
		with real-time ongoing reporting of location estimates and room dimensions
	responding to queries
	executing commands
	
Sensors to use:
--------------
I have several types of Sonar and IR Transceiver Sensors to draw from, as well as a 
3-Axis Magnetometer, for which I have code that implements a Tilt-Compensated Compass
on it.

I propose having Sonar facing forward, and IR Transceivers pointing in the other three 
directions, to detect/prevent tangential and backing-up collisions, and ensure parallel
following of walls, with no veering towards or away from them.

Potential Goals/Sub-Tasks/Behaviors/Negative Sensor Feedback Loops:
------------------------------------------------------------------
1. My first Sensor<->Robot Feedback Loop to implement is Robot Rotation tied to the 
   Compass.  This will require using the existing m3pi Library to drive the wheels, 
   line-follower Sensors, PZ Speaker, etc., and implementing I2C communication with 
   my existing 3-Axis Magnetometer and its Tilt-Compensated Compass code.
   
1a. Calibration for Tire Scrub losses, etc., will be attempted by using the Sonar 
    with some sort of Training Jig, i.e., one or two rings of Construction Paper with 
	10-degree wide slots cut in them, where I rotate one ring, to progressively narrow 
	the slots, and/or perhaps use the built-in Line-Following Sensors for rotational 
	calibration on top of a 36-arm Starfish-like Jig of thin Tape.  Both of these Jigs
	I could draw in some graphics program, and just print them.
	
1b. To debug and calibrate the 3-axis Magnetometer (= Tilt-Compensated Compass) and 
	wall-Following, I’ll implement an analog 2-Axis Joystick.
	Pushing the Joystick around in a circle at full-scale deflection will command the 
	Robot to Rotate either clockwise or counter-clockwise, and a smaller deflection 
	(with no circular motion) will command the Robot to rotate to that heading, and 
	start rolling at a speed proportional to the deflection.
	Various tutorials for Joystick programming here:
	    http://learn.parallax.com/KickStart/27800
		https://www.sparkfun.com/tutorials/272
		http://www.arduino.cc/en/Tutorial/JoystickMouseControl

2. Once Rotation is as calibrated as it can be, I want to implement wall-following, 
   where the side-looking Sensors prevent gradually veering, either into, or away from,
   the wall that the Robot is following.
   
3. Once wall-following is working as best it can, I'll try to implement wall distance 
   measurement, to begin the task of creating an X-Y Coordinate System, in which to map 
   the room.
   The distance measurement will be based on combining counting wheel rotations, with 
   Sonar measurements along a wall, to as great a distance as the Sonar can measure 
   accurately.
   
4. Once some basic mapping data collection is working, I want to implement display of 
   the data on a web page pushed out by the robot via a WiFly on it.  I'll try to
   implement both Ad-Hoc and DHCP IP Addressing, in case UCSC Extension's Wi-Fi doesn't
   allow a Server to be added to it.
   
5. Once I have implemented a basic Query & Response web page interface, I want to add 
   either of a HTML5 canvas or svg tag, and in it both display the Robot's path and 
   wall findings, as well as allow directional guidance to be input.
   
6. My ultimate GUI goal is to support multi-touch gestures in the map, i.e., Pinch for 
   Zoom, and 2-finger Twist for rotating the Map.  Theoretically my Laptop's Touch 
   Screen driver can deliver such events to applications, so it's a question if either 
   Java Apps or some combination of Javascript+HTML5+whichever Browser can receive them.

Issues to resolve along the way:
-------------------------------


Findings along the way:
----------------------
Joystick:
  I wanted to check for "unreachable coordinates" with my Joystick, as jerks in its 
  output data may lead to my Robot crashing into the wall, zooming out of control, etc.
  
  The 1st graph in "x_and_y1_and_y2-scan-data.xlsx" shows when I dragged the Joystick 
  from left to right, moved down a tiny bit, then did it again.  This shows pretty uniform 
  coverage, except for Quadrant IV.
  
  For the 2nd graph in the .xlsx file, I dragged the Joystick top to bottom, moved right 
  a tiny bit, then did it again. My first guess is that this shows the Y’s Pot. is very 
  dirty, and has many dead spots.

  I haven't used this Joystick before, so perhaps as I begin to use it more, it will 
  become better behaved over time.  Hope so.
  
  I need to convey my Joystick output to my mbed input (via my XBee Dongle).  I was 
  thinking about writing a little perl script that just reads from COM21 (= my Arduino
  Nano) and writes what it read from there to COM27 (= my mbed).  Luckily, I found here:
  
      http://perlguru.com/gforum.cgi?post=43583;guest=
	  
  where it says that I need to open COM ports > COM9 with this syntax:
	  
	  open( PORT, "\\\\.\\COM21") || die( "open failed.\n");
	  
  So now in the Perl debugger, I can see my Joystick's output data as follows:
  
    DB<7> open( PORT, "\\\\.\\COM21") || die( "open failed.\n");

	DB<9> p <PORT>
		xVal: -2 :yVal: 1
		xVal: 3 :yVal: 1
		xVal: 15 :yVal: 3
		xVal: 5 :yVal: 1
		xVal: -4 :yVal: 1
		[...]
		
In setting up to use the mbed RPC Library that I described here:

    https://groups.google.com/forum/#!topic/spring2015_e4357/Uxt0BtRg5BQ
	
I found that the mbed Cookbook entry that I referred to is now out-of-date, 
so I found another RPC example that does work in developer.mbed.org/compiler 
here:

    https://developer.mbed.org/users/ban4jp/code/SerialRPC_rtos_example/docs/tip/

I.e., in my main.cpp I have:

    #include "mbed.h"
    #include "rtos.h"
    #include "SerialRPCInterface.h"
    #include "RPCVariable.h"

    float f = 42;
    int   i = 43;
    char  c = 'b';
    RPCVariable<float> rpc_f(&f, "f");
    RPCVariable<int> rpc_i( &i, "i");
    RPCVariable<char> rpc_c(& c, "c");
	
	int main()
	{
		SerialRPCInterface rpc( USBTX, USBRX);
	}
	
In my developer.mbed.org/compile program, I've imported these libraries:

	mbed-rpc
	mbed-rtos			// Not sure if this one is needed for our purposes.
	RPCInterface-rtos	// I only use this because the other similar libraries don't compile.
	
In my Serial Terminal program (connected to my mbed), when I just hit the Enter key, 
my mbed sends back this Help message:

    c i f SPI Serial Timer PwmOut DigitalInOut DigitalOut DigitalIn RPC

meaning that "c", "i", and "f" are my variables that I can query and set, 
as well as typing /RPC/something, DigitalIn/something, etc., as shown here:

/c/read		prints:
b
/f/read		prints:
42
/i/read		prints:
43

The caveat so far is that only the first of the above works, then it just prints out the 
Help message in response to further commands.

I'll google more to learn how to clean out the queue, so further commands can work.

And it's bigger than the demo-Keil will allow, so once I get my near-term functionality 
implemented (= the Robot is moving following my Joystick motions), I'll google a bit more 
to find a non-RTOS version of this, that will fit into the demo-Keil.

Update:
I finally realized (after much google'ing), that the newest version of the SerialRPCInterface
code:

	Description: https://developer.mbed.org/cookbook/RPC-Interface-Library
	Code:        https://developer.mbed.org/users/MichaelW/code/RPCInterface/
	
is Version #8 (28 Jan 2012), as shown in developer.mbed.org/compiler, by right-clicking on
this Library in Program Workspace under your program, choosing "Revisions...".

That means that in order to get the SerialRPCInterface Library to compile, I need to 
right-click on the mbed Library for my program, click on "Revisions...", and click on the 
newest version prior to that date, and click on "Switch", which is Version #36 (26 Jan 2012).

Once I switched to this ancient version of the mbed Library, the RPCInterface 
(aka SerialRPCInterface) Library compiles just fine, though it still only works
the first time I send it a query.  

The good news is that now I can compile and debug into it in Keil.  If you have the 
32kByte-limited version of Keil, rather than the 30-day-limited version, to get past
the 302kByte-limit, I propose to comment out some of these lines:

    SerialRPCInterface.cpp:40:
	void SerialRPCInterface::_RegClasses(void){
    //Register classes with base 
>>> // Base::add_rpc_class<AnalogIn>();   <<<<<<<<<
	// ... 
	
Comment out whichever of these add_rpc_class() calls for mbed capabilities that you won't 
be using.  

I.e., I commented them all out except for <AnalogOut>, and my Keil code size became 
28080 bytes during linking, and 30680 bytes loaded into the mbed.

Uncommenting out one add_rpc_class() call added 192 bytes during linking, and 228 bytes 
loaded into the mbed, so you can calculate how many more add_rpc_class()'s you can 
uncomment out, and still fit into the crippled Keil.

Next I'll debug into it and try to see why it only replies to the first command.

In Keil, I unchecked:

  Options for Target->Debug->CMSIS-DAP Debugger->Settings->
    Debug->Stop after Bootloader
	
Doing so causes this error:

    Address execution break already exists, 
	redefine existing breakpoint?
	
Clicking on either of No or Yes causes this error:

    Cannot access target.
	Shutting down debug session.
	
So I left that checked, and tried unchecking this instead:

  Options for Target->Debug->Run to main()
  
This causes the same first error as above, but if you click "No",
it lets the program run to hit your first breakpoint, rather than 
stopping at the start just prior to entering main().

Update:
I should mention that the SerialRPCInterface Library receives RPC calls 
via interrupts, which (I believe) is superior to the polling approach 
in a while (1) loop that you can see here:

    https://developer.mbed.org/questions/3897/AnalogIn-not-working-in-rpc/
	
Update:
Alas, my changes to RPCFunction.cpp were unsuccessful, so I'm setting that 
aside for now in favor of implementing my next functional block, which is 
the data path between my JoyStick+Arduino, to the m3pi left()/right() and 
motor_left()/motor_right() RPC functions, which do work.

To do this, I'll write a very small Perl "bridge" script, which will read
the JoyStick's R+Theta values from COM23, and write the corresponding 
m3pi-RPC commands to the mbed, first via USB on COM28, then later via XBee
on COM20.  When I make that change, the corresponding mbed code change will
be from:

   SerialRPCInterface rpcInterface( USBTX, USBRX);
to:
   SerialRPCInterface rpcInterface( p28, p27);
   
as that's where the m3pi's Radio Socket's TXD and RXD connect to the mbed.

I also have to further increase the noise rejection of the JoyStick program.
I'm thinking of cutting its Theta output into 8 octants.  For the R value, 
I'll first try cutting it down to be one of 5 values: 

	< 75  = noise, i.e., ignore
	next 1/3rd = 1/3rd of full-speed in the specified direction, after rotation
				 with reference to the Tilt-Compensated Compass (= 3-axis Magnetometer)
	next 1/3rd = 2/3ds of full speed, ditto.
	last 1/3rd = full speed, ditto.	
	> 900 = full-scale deflection, = Rotation mode, rather than Bearing mode.

I'll parameterize the lower-noise and full-scale deflection thresholds and the 
number of steps between zero-speed and full-speed, to simplify adjusting them
in response to however noisy the JoyStick turns out to be in actual use.

I found that these noise-filtering settings worked well for this particular JoyStick:

	const int numThetaSectors = 8;
	const int noiseCeiling    = 120;
	const int fullScaleFloor  = 900;
	const int numRadiusRanges = 8;
	
I also added a check to prevent unwanted points when the JoyStick is snapping back to center.

Update:
------
I'm attempting to abandon the Perl JoyStick->mbed Bridge script in favor of
hosting the JoyStick on an Arduino Fio, which will communicate with the mbed
via XBee.

Initially, I'm programming the Fio using this:

   http://moderndevice.com/product/usb-bub-i/
   
which I've jumper'ed to output 3 Volts to the Fio (both Data lines and Vcc), 
as it's a 3V part.

The photo "Arduino-Fio Joystick vs. Arduino-Nano Joystick.jpg" shows the 
new Fio JoyStick hosting arrangement in the foreground (the small red board 
is the FTDI programmer), and the old Nano host (plus XBee carrier, which is
built into the back of the Fio).

I only wish I had soldered these stackable headers:

    http://shop.evilmadscientist.com/partsmenu/251
	
onto the Fio instead of the usual ones, as then it would be much easier to 
wire up the Fio.

Update:
------
Programming the Fio with the USB Bub above works fine, and I can 
communicate with the Fio's running program via XBee as well, but
I can't yet program it via XBee.

To get the Wireless Programming of the Fio working, I'm following the 
steps in the web pages below, which I'll summarize here:

Referring to these photos...

    Fio Wireless Programming Soldering Steps-p1.jpg
    Fio Wireless Programming Soldering Steps-p2.jpg

On the Fio (mine's board is black), there is a very tiny solder jumper point, 
that needs to be closed to support Wireless Programming.

It may or may not already be soldered in when you buy your Fio.  It doesn't
need a wire to close the gap, only a very tiny solder blob.

Your XBee carrier board needs to have a very short wire jumper soldered between
the RTS pad and the Data IO Pin 3 pad.

Solder the wire on the opposite side of the XBee carrier board from where the 
XBee socket is, so you can easily see that the jumper is in place, without 
having to remove the XBee to check.

If you're using Windows, do this step, which I'm quoting from here:

    http://www.jeffhoefs.com/2013/06/wireless-firmata-using-xbees/
	
    In the Device Manager, select the USB COM port. 
	Then right click and select Properties. Click on the Port Settings tab, 
	and click on Advanced..., then make sure "Set RTS On Close" is selected 
	and click OK to apply settings. 
	(these instructions copied from http://arduino.cc/en/Main/ArduinoBoardFioProgramming)
	
I also got some valuable info from here:

	https://www.sparkfun.com/tutorials/122

Referring to those directions above, I updated my XBee's firmware by doing the
following:

	Run X-CTU from digi.com, and inside it, ...
	Click on Modem Configuration->Modem Parameter and Firmware->Read, 
	to determine current firmware version and settings
	Click on on Modem Configuration->Versions->Download new versions.  
	It took quite a while to do that, seemingly downloading every firmware 
	version for every Digi product in the known universe.
	Click on the Version pull-down menu, and choose the newest version.
	Check the "Modem Parameter and Firmware"->"Always Update Firmware" checkbox.
	Click on "Modem Parameter and Firmware"->Write.
	
Once I'd upgraded my firmware, I next used X-CTU to change the following for my 
Remote unit:

	Networking & Security->PAN ID->(my id#, anything in the range: 0-0xffff)
    RF Interfacing->Power Level->(0) Lowest
	Serial Interfacing->Interface Data Rate->(6) 57600 baud
	(57600 is the baud rate used by the Fio's Bootloader, 
	 which is why this speed is used)
	 
	I/O Settings->D3->(5) DO HIGH		# Digital Output, active-high.
	I/O Settings->IU->(0) DISABLED
	I/O Settings->I/O Line Passing->(FFFF)->Set->OK
	
	Networking & Security->MY 16-bit Source Address->(1) This is unit #1.
	
then clicked on "Modem Parameter and Firmware"->Write.

For my Base unit, I did the same, except for:

	I/O Settings->D3->(5) DI	# = Digital Input.
	I/O Settings->DIO Change Detect->(8) # = 0b1000, which is Pin 3
	(no I/O Line Passing change for the Base unit)
	(no Power Level change for the Base unit)
	(no Source Address change for the Base unit)

	Networking & Security->Destination Address High & Low = ffff
	
From here:

	http://www.arduino.cc/en/Main/ArduinoBoardFioProgramming
	
I added in the Base settings:

	Networking & Security->XBee Retries->(3)
	Serial Interfacing->Packetization Timeout->(10)
	
For safe-keeping, I clicked on Modem Configuration->Profile->Save, and saved
a .pro file for both my Base and Remote XBees' configuration.

If you change the Baud Rate, after you write the new settings to your XBee, 
in X-CTU, go back to PC Settings->Com Port Setup->Baud, change it to your 
new speed, and click on Test/Query.

If all went well, it will say, "Success".  If not, try changing the Baud
pull-down menu back to the original speed (usually 9600), and click on 
Test/Query again.

Back in:

    https://www.sparkfun.com/tutorials/122#Step4
	
makes a start at explaining how all this DIO3-fiddling in X-CTU works, to 
facilitate Wireless Programming.

It's explained a bit more thoroughly here:

    http://www.arduino.cc/en/Main/ArduinoBoardFioTips

Here:

	http://forum.arduino.cc/index.php?topic=123835.0
	
it also suggests doing this to both units in X-CTU:

	I/O Settings->DIO7->(0) Disable CTS Flow Control
	
I'm going to try first without this though.

Some more of the above info is spelled out here:

	http://www.semifluid.com/2012/09/07/arduino-fio-low-power-setup/
	
Update:
------

I was reading here on XBees:

	https://www.parallax.com/sites/default/files/downloads/32400-XBee-USB-Adapter-Documentation-v1.0.pdf
    https://davidbeath.com/posts/reading-xbee-rssi-with-arduino.html
	
and thought it might be good to perform this procedure:

	Test Communications Link and Establish a Network: Perform a Range Test

as described here:
	
	http://ftp1.digi.com/support/documentation/90002160_A.pdf
	
I made a few screenshots here:

	"XBee-USB Cable-Trim off corner to fit XBee Carrier-p1.png"
	"XBee-USB Cable-Trim off corner to fit XBee Carrier-p2.png"

showing how I had to trim off the corner of the USB cable's plug, to allow
it to fit when plugging it into the small XBee carrier board.

To perform the test on pg. 12, I added a jumper between DIN and DOUT on the 
XBee carrier board.

In "XBee-Loopback Testing-p1.png", you can see the jumper I added above on 
the "Remote" XBee.

To maximize my Robot's Battery Life, I set the Remote XBee's "RF Interfacing->
Power Level" to (0)-LOWEST.

With this setting, I found that dropped very few packets with the Remote XBee
as far away as in the next room, and was able to keep at least intermittent 
communication up (= the RSSI light stayed on) until I finally entered the room 
at the opposite end of my home.

In the future, I'll want to configure API mode as described in the .pdf file 
above, and as described here:

	http://knowledge.digi.com/articles/Knowledge_Base_Article/Digi-API-Frame-Maker
	
but that can wait for now.

Lastly, the XBee's ignal Strength (via the PWM signal on its RSSI pin) can be 
monitored as described here:

	http://letsmakerobots.com/node/37243
	http://log.liminastudio.com/itp/physical-computing/measuring-xbee-signal-strength-from-the-rssi-pin
	https://davidbeath.com/posts/reading-xbee-rssi-with-arduino.html
	
Update:
------	
	
After doing the above, in my Serial Terminal program I clicked on-and-off the RTS 
signal, which is what the Arduino IDE does to signal the Arduino's Bootloader that 
it's time to receive a new program.

I used an LED+Resistor to confirm on my XBee USB dongle that its RTS pin (now 
jumper'ed to XBee pin DIO3) is toggling when I click on my Serial Terminal's RTS 
button.  

I followed that by using the LED to confirm that on the "Remote" XBee its DIO3 is 
also toggling when I click the Serial Terminal's RTS button.

Lastly, I installed the XBee on the Arduino FIO, and confirmed that the DIO3 pin
is still toggling in sync with the clicking the Serial Terminal's RTS button.

After all this, I tried Wireless Programming the Fio again, and now it works :=).

Update:
------

Moral: Just use my Profile (.pro) files to program your XBee's, rather than subjecting
	   yourself to all the headaches that I encountered above:

	https://github.com/NeuroDuck/e4357/tree/master/project/Joystick/
		XBee Profile-Base.pro  
		XBee Profile-Remote.pro

Use the "Base" Profile (.pro file) as is, in digi.com's X-CTU XBee programming tool,
to program the XBee which will be directly connected to your PC.  Its node id# is 0.

Use the "Remote" Profile (.pro file) to program the XBees that you connect to each of 
your slaves.  The node id# in this Profile is 1.  Increment the node id# prior to 
programming the XBee of any slave.

Both Profile (.pro) files are configured for "Lowest Transmission Power Level", to save
battery life in the embedded application.

The "Base" Profile is configured to set the Base XBee's DIO3 pin as an input, and to 
propagate the data that is input into that pin (i.e., from your PC's USB cable), 
outward through the radio to all of the slaves.

The "Remote" Profile is configured to set the Remote XBee's DIO3 pin as an output, 
and to receive data via the radio from the Base XBee's DIO3 pin, and output that 
data on the Remote XBee's DIO3 pin.

I.e., on the Arduio Fio, the XBee's DIO3 Output pin is wired to the MCU's Reset pin,
with a small capacitor in series, to give the Remote's MCU Reset pin a short pulse, 
when the XBee's DIO3 signal drops and stays low.

I want to have multiple Robots collaborate on doing various tasks, i.e., as described
here:

	http://www.cliffolling.com/ArukuGo/
    http://letsmakerobots.com/node/35134
	
So I'll update again if I have time to look into either of XBee API or Mesh 
communication modes.

Update:
------

Checking in first working code that drives the Robot via XBee from a JoyStick 
connected to an Arduino Fio, as shown in:

	"mbed Controlled via XBee by JoyStick connected to Arduino Fio.png"
	
Update:
------

As shown in:

    "git\e4357\project\Joystick\New JoyStick-Theta-Sector Patterns-to support Steering.txt"

to create turning capability, I switched the JoyStick program to subdivide its circle into
16 sectors, where theta =0 & =8 are Rotate right & left, and =4 and =8 are drive forward 
and backward.

I assigned the 3 theta values in between each of these to represent {slight,medium,hard}
turns.

Alas, I discovered that this JoyStick is too coarse to be able to produce/distinguish this 
many theta values, at least for radius values <= 50% of full-scale.

To address this, for radius values <= 6 (out of a maximum of 9), I now smash the 3 turn 
values into only 1.

[Edit: I should instead smash them into being the largest-radius turn of the 3, rather 
       than the middle one.  I ultimately did this below.]

I imagine that further testing will reveal that I'll basically have to just raise the 
noise floor significantly above its current value of r=120, as the JoyStick just doesn't
have enough angular resolution (to support having 3 different radii of turns) with 
JoyStick deflections of less than that.

Update:
------

Possibly due to having switched the XBees to the "LOWEST" transmission power setting, the
mbed is now receiving lots of garbled messages from the JoyStick.

To address this, I've implemented a fixed-length 8-byte(+CR) JoyStick message format of 
the form "!r tt cc", where:

	r == JoyStick radius value
	tt = JoyStick Theta value
	cc == checksum (= sum of r + tt) value
	
In the mbed code, I added a simple parser function, that is called like this:

	int rVal = 0, thetaVal = 0, checksum = 0, dummy = 0;
    char fieldsSpec[] = "!1d1 1d2 1d2";
    int* results[] = { &dummy, &rVal, &dummy, &thetaVal, &dummy, &checksum };

	int invalidFieldNum = checkFields( cmd, fieldsSpec, results);

    if (invalidFieldNum <= -10)          					// The length was incorrect.
	{ ... }										// Actual length = 10 + invalidFieldNum;
	
	if (thetaVal < 0 || thetaVal > numThetaSectors - 1)		// Theta wasn't valid.
	{ ... }
	
	if (rVal + thetaVal != checksum)						// Checksum failed.
	{ ... }
	
	if (invalidFieldNum != 1)								// Fieldnum# -invalidFieldNum
	{ ... }													// had a problem.

I found that I reached a point with the Keil Debugger, where I needed to let the program 
run at full speed to find bugs/hangs, etc., that stepping past breakpoints would not 
accomplish.

I suppose I could have made a variable-incrementing if-statement, and set a breakpoint
inside its { block } to fake a conditional-breakpoint, like Visual Studio has.

Instead I decided that I'd rather have a place to print the mbed's debugging messages 
during Wireless operations (and to support later new features), so I added this 2x16 
ASCII display to the JoyStick:

https://www.parallax.com/sites/default/files/downloads/27979-Parallax-Serial-LCDs-Product-Guide-v3.1.pdf
http://learn.parallax.com/KickStart/27977

On its top line, it displays its outgoing messages, now of the fixed-length form described
above.

On its bottom line, it displays messages received from the mbed, to aid my debugging.

To save the battery, the Display's backlight is toggled by a debounced momentary 
pushbutton.

Alas, this Display is a 5V part, my Arduino Fio has no 5V output, and I didn't want to risk 
burning it up, so I installed a Voltage Divider off of the 4xNiMH batteries (= 5.41V) as 
shown in:

    "JoyStick Display+Voltage Divider.jpg"
	
to step it down to ~5.0V.  I found that to get the Display to work, I had to use very low 
values in the Voltage Divider ( [vBatt <- ~10 Ohms "." 100 Ohms -> Ground], where the 
Display is connected to the "."), or the Display couldn't get enough current to operate.

My resistors are only 1/8W, so to avoid melting them, I put 2 of double the values above in 
parallel to achieve each of the values above.

When I get time to buy a 2-Cell LiPo battery, I will replace the Voltage Divider with a 
LM7805 7V->5V Voltage Regulator.

In the meantime, I became brave, and hooked the Display directly to the Battery, and it's 
working well with no Voltage Divider. 

Next I'll wade through the mbed's messages on the JoyStick display, to further debug the 
mbed's processing of the JoyStick commands.

Update:
------

I added a (22k Ohm . 10k Ohm) Voltage Divider from Vbat <-> Ground, from which I'm measuring
and displaying the Battery Voltage.  I need to knock it down by 2/3rds, to ensure that the 
8.4V of a fully-charged 2-Cell LiPo Battery will still be < 3.3V, as that's what the Arduino 
Fio's is running on.

The JoyStick's Display now has 3 sections:

	Upper-left:  JoyStick command sent to Robot
	Upper-right: Battery Voltage
	Bottom line: Response from Robot, and JoyStick status messages

The momentary toggle-in-software Button (used to cancel waiting, and to toggle the Display 
back-lighting) still has a few issues, but otherwise the JoyStick code now has the debug 
message printing and "JoyStick blocking when waiting for input"-capability that I was 
envisioning.

I'll leave the button functionality as is for now, and use this new JoyStick display to 
finally return to debugging the Robot's turning functionality.

The only JoyStick addition remaining that I plan to do, is to add a DIP of 8 tiny switches
connected to pins D2-D9.

This will allow the user to choose which of a multitude of functions to run when the button 
is pushed.

I'll also use one of the DIP switches to enable/disable "Wait for Robot reply before 
allowing new JoyStick input", which blocks future JoyStick inputs, when awaiting a reply 
from the Robot to the previous JoyStick command sent to it.

The photo "JoyStick Display-startup.jpg" shows the startup state of the JoyStick's new 
Display, and the Voltage Divider I'm using to measure an (upcoming) 8.4V LiPo 2-Cell battery
with one of the Arduino Fio's 3.3V ADC pins.  When I migrate from my current 4xNiMH batteries
to the 8.4V LiPo one, I'll add a Voltage Regulator to provide 5V to the Display.

In this photo, the Display's upper-left corner is blank, indicating that currently no JoyStick
command has been sent to the Robot, thus no response is being waited for, and JoyStick input 
is enabled.

As shown in the photo "Sent JoyStick Cmd. to Robot-Awaiting Response.jpg", when the user moves
the JoyStick, a command is sent to the Robot and shown in the Display's upper-left corner.

For debugging purposes, I've set the JoyStick's program to block further JoyStick input while 
it is awaiting a response from the Robot.  To allow for the Robot never responding, the Display
shows a reminder that pushing the JoyStick's PushButton will cancel the blocking/waiting, and
re-enable JoyStick input.

The photo "Response from Robot.jpg" shows the Robot's response.  The Display's upper-left 
corner is blank, indicating that no command has been sent/is being waited for, and that 
JoyStick input is enabled.

The photo "Wireless Debugging message received from Robot.jpg" shows the JoyStick wirelessly
receiving a debugging message from the Robot.

Update:
------

The JoyStick's debugging Display is starting to bear fruit.  

On the minus side, it is apparently suffering from overruns due to data arriving too 
fast from the Robot to be pushed to the Display at its max. 19200 baud rate.

I've somewhat addressed this by adding wait_ms() everywhere I send to the JoyStick.

Data on the Display is still intermittently appearing in the wrong place, so some 
more wait_ms()'s are no doubt required, to allow the Display time to keep up.

On the plus side, having the Robot's debugging messages appear on the JoyStick Display
while the Robot is driving around is proving helpful, with the result that the Robot 
is now much closer to turning in the directions directed by the JoyStick.  

For safety during testing, I have the Robot stop itself 2 sec. after receiving any 
driving/rotation command.

All of {left,right}{rotation,turn}{forward,backward} seem to be working at at least 
a rudimentary level.  

The only caveat is that the Rotation speed suddenly increases after a second or so.  
This may be due to the base 3pi robot's PID code kicking in.  I'll have to check if 
it's on by default, and disable it until I iron out most of my bugs.

Now when the Robot detects that its battery is getting low, it sends:

    "He's dead, Jim."
	
to appear on the JoyStick's Display :-).

And for when the Robot is "tethered", I added the capability for the user to type in
arbitrary text in the Robot's Serial Terminal window, which is sent to the JoyStick. 
 
This is handy to unstick the JoyStick, when it's waiting in vain for a response from 
the Robot, and to test the sending of future commands to the JoyStick.

Update:
------

I checked in some small tuning changes to the Steering algorithm.  

I found that its ease-of-handling was greatly increased by damping down the Rotation
rate.

The Steering code is in lines 99-362 here:

	https://github.com/NeuroDuck/e4357/blame/master/project/main.cpp
	
I fished through those changes, and found that the most helpful steering tweaks were
probably these:

	"Tune the Steering algorithm a bit, to make it less twitchy, so it becomes easier 
	 to make small course-corrections, while driving at high speed."
	https://github.com/NeuroDuck/e4357/commit/9d38d903fe8e3d9df45eea4f86f53576deec82e0

main.cpp:180:
-		float rotationSpeed = 1.0 * r / numRadiusBands; 
+		float rotationSpeed = 1.0 * r / numRadiusBands / 8; 	// (rotate _much_ slower).

as it was just spinning 'way too fast to control which way it ended up pointing.

I also made a temporary trade-off, of allowing faster driving, while blocking the
ability to make the two levels of tighter-radius turns, as shown here:

main.cpp:193-199:
-	float fasterWheelRatio =        wheelRatios[theta]  * r / 500.0 / 4;
-	float slowerWheelRatio = (100 - wheelRatios[theta]) * r / 500.0 / 4;
+	else if (theta != forwardTheta)					// == We're turning.
+	{
+		 theta = 3;			// Limit us to the most gradual turn of the 3 for now.
+	}
+	
+	float fasterWheelRatio =        wheelRatios[theta]  * r / 500.0;
+	float slowerWheelRatio = (100 - wheelRatios[theta]) * r / 500.0;

I also went through everywhere main.cpp is sending commands to the underlying 3pi Robot,
and added wait_ms() after each transmission, to allow enough time for it to complete at 
the 115200 baud rate being used.  

I added wait_ms() in the JoyStick code where it's sending characters to its Display at 
the Display's max. 19200 baud rate.

Now I'm starting to test my old Compass that I bought a few years back:

    LSM303DLM 3D Compass and Accelerometer Carrier with Voltage Regulators ($5.95)
    https://www.pololu.com/product/1273

It is being phased out, so I also bought this new one:

    LSM303D 3D Compass and Accelerometer Carrier with Voltage Regulator ($9.95)
    https://www.pololu.com/product/2127

Alas, in my m3pi Robot, as shown in:

    "project/Compass/m3pi_I2C-Conflict_Schematic.gif"
	
both pairs of the mbed's I2C bins being used for something else.  I.e., the mbed uses 
p9 & p10 to tell the “downstairs Robot” to spin the wheels, report the Battery Voltage, 
etc., and it uses p27 & p28 to talk with the XBee radio.

Luckily, here:

    http://forum.pololu.com/viewtopic.php?f=29&t=6187

I found that there is a SoftwareI2C Library available here:

	https://developer.mbed.org/users/p3p/code/SoftwareI2C/docs/8670e78c4b63/SoftwareI2C_8h_source.html
	
that can do I2C on any two unused Pins, so I'll try that out.

Update:
------

Aside: While working in Panera, where apparently all the Wi-Fi users may make for a noisy 
	   RF environment, I found that when doing my Wireless Programming of my Fio via XBee 
	   (w/transmission power set = "LOWEST"), my max. Wireless Programming range was ~6-7 
	   inches.  Really, trying to program from 10 inches away, I was only able to succeed 
	   about 1 time in 10 tries.

Aside: Re: Sonar, Pololu has a very helpful beam width/depth chart here:

	https://www.pololu.com/picture/view/0J1969

	The manufacturer's Selection Guilde is here:
	
	http://www.maxbotix.com/SelectionGuide/Selection-Guide.htm
	
	And their FAQ is here:
	
	http://www.maxbotix.com/tutorials.htm
	
	Ah, here's a better beam comparison chart:
	
	http://www.maxbotix.com/pictures/HRLV/HRLV-EZ%20Sensor%20Beam%20Patterns.gif
	
Aside: Re: Thin LiPo Batteries: Can 2 thin 1S 1Ah LiPo's be safely wired together in 
		   series, wire terminals-to-wire terminals (nose-to-nose), to make a thin 2S 
		   battery pack?

Aside: Re: XBees: #0 goes in my USB Dongle	(Dest=0xff)
		   #1 in the JoyStick		   		(Dest=#2)
		   #2 goes in the mbed Robot   		(Dest=#1)
		   #3 goes in the Rover5 Robot 		(Dest=#0)
	All were programmed using my checked-in .pro files with the above changes, using 
	digi.com's free X-CTU program.
	
Update:
------

I'm checking in project/Compass/calibrate_Compass.cpp, which is used to determine your
particular Compass's full-scale values for Acceleration and Magnetic Field, in your 
particular installed environment, to help it give more accurate readings.

Following up on what I wrote above, the SoftwareI2C library is working well.

I checked in my versions of developer.mbed.org's libraries: LSM303DM & SoftwareI2C, 
as I had to slightly modify both to allow them to compile together.

I added a bit of the DIPswitch support to the JoyStick.  Now is the point where it 
would be handy to use one of the mbed RPC libraries, but they all seem to be out-of-date
(read: they don't compile against the current mbed library).

So instead I'll add to the existing syntax (see the next update below) that I'm already 
parsing, and use it to send my commands and queries to the Robot.

The intention is that I will add 8 or more tiny switches (currently they're just wires to 
Ground).

When the user pushes "the JoyStick's Button", functions in the Robot will be run, selected 
by whichever of the DIPswitches are in their "active" state.  I'll probably create some
sort of primitive way for the user to specify an argument to the function invoction as well.

I'll be adding a Compass to both the JoyStick and the Robot, so the Robot can steer 
relative to the JoyStick's "forward" direction, rather than relative to the Robot's 
"forward" direction.

On the JoyStick's Arduino Fio, D2-D10 (= 9 bits) and A0-A4 (= 5 bits) are available 
for use as DIPswitches (14 bits total).

Currently I'm envisioning using 4 of these bits to specify a heading argument for my 
function calls to the Robot (the JoyStick only produces 16 possible heading values, 
2 of which are Rotate left and right, rather than being any amount of forward/backward 
motion.

Likewise 3 bits can be for invoking any one of 8 Robot functions.

The remaining 7 bits for can be for invoking one or all of 7 different Robot functions.

More on this in the next update (already partially fleshed out below).

Update:
------

Next: Write up DIP Switch-driven command syntax to send to the Robot.

To wit:
	!r th cc   Driving command: r=0-9 speed, th=0-15 direction, cc=checksum.
	@xxx[=yyy] Query or set parameter xxx [to yyy] in the Robot's Parameters assoc. array.
	%xxx[=yyy] Do the same in the JoyStick.
	*xx nn cc  Call function xx on the Robot (specified by the JoyStick's DIPswitches), 
			   with nn arguments to follow, and cc=checksum.
	(argVal cc An argument for the previous Robot function call.
	
Update:
------

Some notes for the upcoming Compass Calibration Line-Following Algorithm...

In libpololu-avr library that I downloaded from here:

	https://www.pololu.com/docs/0J20/2.a
	https://www.pololu.com/file/download/libpololu-avr-150324.zip?file_id=0J865
	
For completeness, more background is here:

	https://www.pololu.com/docs/0J21/7

I'm looking in:

	libpololu-avr\examples\atmega328p\3pi-demo-or-serial-slave\serial-slave.c

for the details on its PID algorithm.

I.e., in my Robot code, theoretically I would like to call this to smooth out my driving:

	m3pi::PID_start( int max_speed, int a, int b, int c, int d)
	
I found above, that these arguments are:

	proportional_numerator
	proportional_denominator
	derivative_numerator 
	derivative_denominator

used as follows:

	int power_difference = proportional * p_num / p_den + derivative * d_num / d_den;
	
The motors will stop if either denominator is 0.

described as follows.

	Sets up PID parameters and begins line following. The first data byte 
	sets the maximum motor speed. The next four bytes, a, b, c, and d, 
	represent the PID parameters.  
	Specifically, the difference in the motor speeds will be set to 
	(L-2000)×a/b + D×c/d, where L is the position of the line as described 
	above, and D is the derivative of L. The integral term is not implemented 
	in this program. See Section 7.c for more information on PID line following.

So the purpose of this PID implementation is only to adjust the ratio of wheel speeds
during line-following, and not during more generic driving :-(.

If I want to do line-following, I should call sensor_auto_calibrate() while sitting on 
a black line on a white background.  This will rotate the m3pi back and forth, so it can 
calibrate to accurately see the line.

I found that the 3pi Slave code apparently does support: 

	0x87 read calibrated sensors (#defined as SEND_CALIBRATED_SENSOR_VALUES)
		 Reads all five IR sensors and sends calibrated values as a sequence of 
		 two-byte ints, in the range 0-1000.
		 
So after calling placing the Robot on a line and calling sensor_auto_calibrate(), 
add a m3pi::read_calibrated_sensors() function, which I will use in my own function
that drives around "Compass\Compass Auto-Calibration Jig.png" to auto-calibrate the 
Compass.

Update:
------

Now I'm building my Robot's "3rd Floor". 

Aside: Headers: I have 3 different heights of right-angle headers, board-edge ones, 
                "normal"-height ones, and "tall" ones, ugh.
				
On this new 3rd Floor, I mounted these Sensors:

	Front-Looking Sonar
	PADS (aka Ping) Distance Sensor + Cyperbolic(?) Reflector
		http://www.perboliallc.com/projects.html
	Using this library:
		https://developer.mbed.org/users/rosienej/code/Ping/docs/1e4b66122368/classPing.html
		https://developer.mbed.org/users/rosienej/code/Ping/
	
	Side-looking Sonar
	Maxbotix LV-MaxSonar-EZ4 Sonar Range Finder MB1040
		https://www.pololu.com/product/794
		http://www.maxbotix.com/articles/016.htm 	(Quick-Start Guide, Analog Voltage method)
		http://www.maxbotix.com/articles/033.htm	(Pulse-Width method)
		https://www.pololu.com/product/794
		http://www.maxbotix.com/tutorials.htm
		http://www.maxbotix.com/articles/095.htm	(I2C library + example code)
		http://www.maxbotix.com/documents/Arduino%20Codes/I2C_for_MaxSonar.ino
		(The above is for Arduino, but can be a reference for using this via I2C from mbed.)
	Using this library:
		https://developer.mbed.org/users/mkanli/code/MaxSonar/

	Tilt-Compensated Compass
	LSM303DLM 3D Compass and Accelerometer Carrier with Voltage Regulators
		https://www.pololu.com/product/1273
	Using this library:
		https://developer.mbed.org/users/fin4478/code/LSM303DM/
		
	I also have this newer Compass that I'll use on my JoyStick:
	LSM303D 3D Compass and Accelerometer Carrier with Voltage Regulator
		https://www.pololu.com/product/2127

The mbed and Power pins I need to route up to the 3rd Floor to operate these 3 Sensors are:

	Front-Looking Sonar (PING):
		5V, Ground
		Signal		(p8)
		SCL, SDA	(SCL = p29, SDA = p30, migrate to use its I2C interface a bit later)
		
	Side-looking Sonar (LV-MaxSonar-EZ4)
		5V, Ground
		Trigger		(p15)
		Signal		(p16)
		
	Compass (LSM303DLM)
		3.3V, Ground
		SCL, SDA	(SCL = p29, SDA = p30, as defined in my LSM303.cpp)
		Using SoftwareI2C library: 
			https://developer.mbed.org/users/p3p/code/SoftwareI2C/
		
These signals run up my 2nd-3rd Floor Headers as follows:
(viewed looking at the edge of the 2nd Floor board, when it is mbed-side up):

	Right-most: 
	MaxSonar AnalogIn		(p16) (Conflicts with Robot's LED's,)
	MaxSonar TriggerOut		(p15) (but I need an AnalogIn pin.  )
	Ping Signal Output		(p14)
	pin present, but not used
	pin present, but not used
	SCL				(p29)
	Ground				(From 1st Floor)
	5V				(From 1st Floor)
	3.3V				(p40, mbed's Vout)
	SDA				(p30)
	pin present, but not used
	pin present, but not used
	pin present, but not used
	mbed Reset			(nR == p4)
	pin present, but not used
	pin present, but not used
	Left-most:
		
Update:
------

These photos show the forward- and side-facing Sonar sensors and the Compass 
on the newly-built 3rd Floor:

	Robot-Front View.jpg
	Robot-Top View.jpg
	Robot-Right Side View.jpg
	
"Robot-2nd to 3rd Floor Connector details.jpg" shows the connectors added to 
carry signals from the 2nd Floor up to the newly-built 3rd Floor.

"Robot-2nd Floor added Wiring details.jpg" shows the wiring added to the bottom
of the 2nd Floor, to route the necessary signals to the connectors in the 
previous photo.

I'm also checking in updates to the stock mbed MaxSonar and PING libraries, 
to make them work more accurately.

Some delays I encountered, were:

	I re-built part of the 2nd-to-3rd Floor connectors.
	My original PING sensor (from perboliallc.com) turned out to be too 
		unstable to be usable, so I had to remove the PING from my old 
		Robot to use here.

All three Sensors are working now working well, so it's finally time to 
try to write code against them.

Once I write a bit more steering code, I'll add the mbed WebServer library, 
to serve up a live map of the Robot's explorations via the RN-XV WiFly (Wi-Fi)
drop-in replacement for my existing XBee radio.

This will allow anyone on the local network to view the Robot's live exploration
map, steer it, and to query various aspects of its state, i.e., battery life, 
etc.

Update:
------

A week or so ago I re-configured all 4 of my XBee's (the 4th one is in another
Robot that's not part of this project).

Yesterday I found that my Dongle XBee (ID# 0) can no longer talk with, and more
importantly, do Wireless Programming, to the JoyStick's XBee.

So I'm reading up on XBee's here:

	https://www.sparkfun.com/datasheets/Wireless/Zigbee/XBee-Manual.pdf
	
to determine if I can set the JoyStick's Destination Address to be a mask,
rather than a particular address, so it can converse with both my XBee Dongle
and with the Robot.

Update:
------

Oops: Looking though the m3pi User's Manual, I see that the mbed's Pin 8 is 
      wired to the 1st Floor MCU's Reset input :-(.
      As you can see above, I used that mbed Pin for "Ping Signal Output" :-(.
      
Thus it seems prudent to make this list of the mbed's "Reserved Pins", which 
are already dedicated to some use or other by the m3pi, and re-assign any 
of these that I'm currently using to some other uncommitted pins: 

	p5	AVR_MOSI (AVR ISP Programmer chip)
	p6	AVR_MISO (AVR ISP Programmer chip)
	p7	AVR_SCK	 (AVR ISP Programmer chip)
	p8	3PI_RST	 (Reset 1st Floor Robot)
	p9	3PI_RX	 (Receive 1st Floor Robot's Responses)
	p10	3PI_TX	 (Send commands to 1st Floor Robot)
	p13-20	Persistence Vision LEDs
	p23	AVR_nRST (AVR ISP Programmer chip)
	p26	COM_nRST (XBee pin 5)
	p27	COM_TX   (XBee pin 2)
	p28	COM_RX   (XBee pin 3)
	
Relatedly, here are where the XBee pins are accessible on the m3pi board:

	 2	COM_TX		(P1_6 = Wixel Right Header Pin 7)
	 3	COM_RX		(P1_7 = Wixel Right Header Pin 8)
	 4	DO8		(P0_3 = Wixel Left Header Pin 7)
	 6	PWM0/RSSI	(P0_4 = Wixel Left Header Pin 8)
	 7	PWM1		(P0_5 = Wixel Left Header Pin 9)
	 8	Reserved 	(P2_1 = Wixel Left Header Pin 10)
	 9	DTR/SLPRQ/DI8	(P2_2 = Wixel Left Header Pin 11)
				(Note: "U3" aka Bluetooth Header)
	11	AD4/DIO4	(U3_11 = Wixel Antenna Area Column 6)
	12	CTS/DIO7	(U3_12 = Wixel Antenna Area Column 5)
	13	ON/-SLEEP	(U3_13 = Wixel Antenna Area Column 4)
				(& P1_9 = Wixel Right Header Pin 9)
				(Note: Wixel Right Header starts 1 below Ground hole, 1-9 only)
	14	VREF		(U3_14 = Wixel Antenna Area Column 3)
	15	ASSOC/AD5/DIO5	(P1_5 = Wixel Right Header Pin 6)
	16	-RTS/AD6/DIO6	(P1_4 = Wixel Right Header Pin 5)
	17	AD3/DIO3	(P1_3 = Wixel Right Header Pin 4)
	18	AD2/DIO2	(P1_2 = Wixel Right Header Pin 3)
	19	AD1/DIO1	(P1_1 = Wixel Right Header Pin 2)
	20	AD0/DIO0	(P1_0 = Wixel Right Header Pin 1)

Referring to the list above, it seems that my only mbed Pin that I need to migrate 
elsewhere is p8, which I'm using to control the PING Sensor.

I'll add headers on the bottom of the mbed board to allow connections to p11-p14, 
and migrate the PING's signal to one of those.

Relately, the MaxSonar has 4 different interfaces:

	Analog Voltage
	Pulse Width
	RS232
	I2C		(alas, not available in my MaxSonar model)

to return a measured distance, as described here:

	http://www.maxbotix.com/tutorials.htm
	
Currently I'm using the Analog Voltage interface, as that's all that happened to 
be implemented in the available mbed library.
	
Referring to pg. 3 of: 

	"e4357\project\Sonar\LV-MaxSonar-EZ MB1040 datasheet.pdf"

it looks like its Pulse Width interface works similar to the PING's, except with
different timing values.  I.e., send a triggerPulse for >20uS, then wait for and 
read the duration of the response pulse, using the conversion factor of 
147uSec./inch, as described here:

	http://www.maxbotix.com/articles/033.htm
	
The MaxSonar's Analog Voltage distance measurement needed correction, so perhaps 
the Pulse Width-derived or I2C reported measured distances will be more accurate.
I'll write here later when I test these.  

The more basic MaxSonar I2C models are listed here:

	http://www.maxbotix.com/Ultrasonic_Sensors.htm#I2CXL

The good news is that their I2C address is programmable to any valid value (1-239?),
so it won't conflict with other I2C devices on the bus.

Update:
------

I checked in this spreadsheet:

	"e4357\project\Sonar\PING vs. MaxSonar measurement differences.xlsx"

that shows the differences in the reported distances between the PING Sonar Sensor 
and the MaxSonar one.  The spreadsheet also contains the correctedInches() function 
that I added to the MaxSonar library, that now brings the MaxSonar's reported 
distance very closely into agreement with the PING's.

The photo"

	"e4357\project\New Header Pins added for mbed p11-p14.jpg"
	
shows the new Header Pins I added on the bottom of the mbed board to allow access to
p11-p14.

I added these Pins because it turns out that my use of p8 to signal the PING Sensor 
was causing problems with the 1st Floor Robot.  p8 is wired to the 1st Floor Robot's
Reset line, so I migrated the PING's signal from the mbed's p8 to p14, now carried
by the blue wire on the rar-right side of the photo above.

Update:
------

Re: XBee Configurations:

To keep things simple for now, to resolve the issue of the JOYSTICK's XBee not 
wanting to talk to the LAPTOP's XBee (= the one that I do Wireless Programming 
with), I set the JOYSTICK's XBee's Destination Address (low bits) = 0xffff = 
Broadcast.

Alternatively, I also found that I can name each XBee, thus they are now named:

	LAPTOP		(Node #0)
	JOYSTICK	(Node #1)
	MBED1		(Node #2)
	ROVER5		(Node #3) (= My previous Robot project, still ongoing)
	
Interestingly, I can switch any XBee from Transparent (= my normal use) mode to
Command Mode by typing to it "+++", without the Enter character.

Then I can type in any of:

	ATDNLAPTOP
	ATDNJOYSTICK
	ATDNMBED1
	
to easily set it to talk with the desired target XBee.  
Note: The target XBee has to be currently on-line to allow this to work.

By default, the XBee will automatically switch from Command Mode back to Transparent
Mode after 6.4 sec. idle time.

It seems that having the JoyStick's XBee's Destination Address (= DA) set to 0xffff, 
does not allow Wireless Programming to work, so I've temporarily switched it to 0x0, 
so it can talk with the Laptop's XBee.  I'll switch the DA back to 0x2 when I'm done
programming it.

I'm in progress on wiring up 12 DIP switches for the JoyStick, so I'll assign 2 of
them to be read in the JoyStick's setup() to specify the target XBee DA.

Update:
------

So far, I've wired up the Ground-side of all 12 DIP Switches, and one of them I've 
connected to the JoyStick's Arduino Fio A0 pin.

I've migrated the display update of the Switches' state from polling in the JoyStick's
loop() function, to being called by a PinChange_ISR() instead.

The Fio only has one UART, which is talking with the XBee, so I'm using a SoftwareSerial
library to drive the JoyStick's LCD Display.

Unfortunately, the SoftwareSerial library claims all 3 of the PinChange_ISR()'s, so
I modified its constructor to take a callersPinChangeISR function-pointer, which it
calls if its own PinChange_ISR() determines that the triggering PinChange is not 
one that it is waiting to process.

So now my JoyStick's PinChange_ISR() is being called by the SoftwareSerial library, 
and I don't need to poll any more to check if any of my DIP Switch settings have 
changed.

While looking into what the SoftwareSerial library is doing, I learned a lot about 
many useful GPIO Pin Control Register manipulation macros, which I've documented 
my findings on in the JoyStick source file, "project/Joystick/Joystick_v02.ino".

Next I'll wire up the other side of the rest of the DIP Switches with some Ribbon
Cable, and hopefully they'll all be working straight away, using this new PinChange
ISR().

Update:
------

Re: JoyStick Code:

Migrated A0's DIP Switch Status position from the end of the "10101101"'s, to the 
front, to match the order that the switches are actually placed on the breadboard.
Connected two more of the DIP Switches to Pins A1 and A2, as there are no more 
Digital Pins left to connect them to.

Migrated the invocation of get_R_Theta() from polling, to be invoked by the Timer1
library, at 20Hz.  Ditto for displayVoltageMeasurement(), which is now invoked at 
1/60Hz.  
 
Add "JoyStick battery dead." check to displayVoltageMeasurement(), and ensure that 
it is actually displayed long enough to be noticed by the user.

These are both currently being polled at full-speed, so this approach is a much more
efficient use of resources.

Grounded all unusued ADC inputs, to decrease battery consumption and ADC noise.

De-jitter'ed get_R_Theta(), so it's not constantly spewing un-commanded JoyStick
output, needlessly tying up the JoyStick's Display.  Especially stop it from 
producing endless r=0 JoyStick output.

Added Calibration Procedure to the JoyStick code, to help ensure that it's producing
correct values.

Completed wiring up of all DIP Switches using Ribbon Cable.  See the photos:

    "New JoyStick Switches and State Display-p1.jpg" & "...-p2.jpg"

Results/Solutions:
-----------------
